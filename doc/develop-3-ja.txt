#SVG pathデータのAコマンドのコーディング


NGを表すアイコンは、次の方法によっている。

1. fontawesomeのpathをロード。
5. pathから、Path2Dを生成。
10. Path2Dでcavasにbitmapを描く。
15. 当該bitmapをWebGLのtextureとする。

この方法は、pathデータを画像クリエイターが用意すれば、処理を変更せずに、表示を変更できる。pathとしているのでアイコンサイズの変更に対しても柔軟性を持っている。
Chromeでは、予想どおりの結果となった。[Path2Dのコンストラクタのapi](https://developer.mozilla.org/ja/docs/Web/API/Path2D/Path2D)をMdnでよく見ると、Edgeが対象外になっていた。Edgeで動作させると、アイコンが消えた。Path2Dの基本図形を表示するapiは当然あるので、SVG pathの構文解析をして、Edgeでも対応するようにすることにした。字句解析レベルで対応できる仕様だとは思うが、人間がテキスト入力してもよいように、いくつかの自動処理が要求されるだろう。SVGの仕様を確認すると、面倒な仕様があった。実装せずにMicrosoftの修正を待つのも一つだが、ChomiumベースのEdgeになるまでサポートされないかもしれない。


[8.3.8 The elliptical arc curve commands](https://www.w3.org/TR/SVG11/paths.html#PathDataEllipticalArcCommands)

Parameters
:(rx ry x-axis-rotaion large-arc-flag sweep-flag x y)+

Description
:..."The center (cx, cy) of the ellipse is calculated automatically to satisfy the constraints imposed by the other parameters."...


楕円の中心を通る2点から自動計算しろって、
これ、そんな簡単ではないよ...

さらに仕様を読み込んで...

[F.6 Elliptical arc implementation notes.](https://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes)


あったー、このままコード書けば、楕円の中心が求められる。
コードを書けばよいのだが、変数が多いので、コードに落とす途中で、バグを紛れ込ましてしまいそう。書いてはみたが、コンパイルエラーはでるし、コンパイルが通っても、NaNが返ってくる...

結局、F.6を理解して、Debugすることに...


##焦点からの距離が等しい座標集合から

楕円は、2つの焦点からの距離が等しい座標の集合とういうことから始めてみよう。
parametersには、X軸をx-axis-rotationだけ回転させた楕円とあるので、

中心\\(p\_c\\)を\\((c\_x, c\_y)\\)、x-asis-rotationを\\(\phi\\)とすると
中心と焦点の距離\\(d\_f\\)は
<div >
$$ 
\begin{equation}
d_f = \sqrt{|{r_x}^2 - {r_y}^2|}
\end{equation}
$$
</div>
焦点\\(p\_{fm}\\)、\\(p\_{fp}\\)は、次のようになる 

<div >
$$ \begin{align}
  p_{fm} &=(c_x - d_f\cos\phi, c_y - d_f\sin\phi) \\
  p_{fp} &= (c_x + d_f\cos\phi, c_y + d_f\sin\phi)
\end{align} $$
</div>

楕円が通るあたらえられた2点を\\(p\_0(x\_0, y\_0)\\)、\\(p\_1(x\_1, y\_1)\\)すると以下の等式が成り立つ。

<div >
$$
\begin{equation}
 \overline{{p_0}{p_{fm}}} + \overline{{p_0}{p_{fp}}}
  = \overline{{p_1}{p_{fm}}} + \overline{{p_1}{p_{fp}}}
\end{equation}
$$
</div>

成分表記すると(書くのも面倒だが)

<div >
$$\begin{align}
  \overline{{p_0}{p_{fm}}} &= 
    \sqrt{((c_x - d_f\cos\phi) - x_0)^2 
      + ((c_y - d_f\sin\phi) -  y_0)^2 } \\
  \overline{{p_0}{p_{fp}}} &= 
    \sqrt{((c_x + d_f\cos\phi) - x_0)^2
      + ((c_y + d_f\sin\phi) -  y_0)^2 } \\
  \overline{{p_1}{p_{fm}}} &= 
    \sqrt{((c_x - d_f\cos\phi) - x_1)^2
      + ((c_y - d_f\sin\phi) -  y_1)^2 } \\
  \overline{{p_1}{p_{fp}}} &= 
    \sqrt{((c_x + d_f\cos\phi) - x_1)^2 
      + ((c_y + d_f\sin\phi) -  y_1)^2 } \end{align}$$
</div>

ここから、\\(p\_c(c\_x, c\_y)\\) を求める式をつくればよいが... 計算を完遂できる自信がない。

もう一度考え直して...

## 座標変換による楕円の中心

楕円は、円を一方向に座標を伸縮させた図形を考えることができる。円を伸縮させて倍率の逆数をかけるともとの楕円になる。 適当な座標変換を繰り返すと、半径１の円にすることができる。

この時、最初の\\(p\_0\\)、\\(p\_1\\)も、座標変換を経て\\(p\_{0t}\\)、\\(p\_{1t}\\)になる。それは半径1の円周上にある。ここまで行けば簡単だ。円周上の2点から中心を求めるのは、小学生でもコンパスを使って求めることができる。 
半径1の円の中心を\\(c\_t(x\_{ct}, y\_{ct})\\)は、逆に戻す座標変換をおこなって、求める楕円の中心とできる。

先にあげたコンパスを使う中心の求め方は、次の計算と同じだ。
円の中心と2点\\(p\_{0t}\\)、\\(p\_{1t}\\)の中点を通る直線と2点\\(p\_{0t}\\)、\\(p\_{1t}\\)を通る直線が直交することと半径から円の中心を求めることができる。


2点を通るの円の中心は、2つ見つかる。
\\(p\_{0t}\\)、\\(p\_{1t}\\)を通る直線の-側\\(c\_{0t}\\)、+側\\(c\_{1t}\\)。
\\(p\_{0}\\)、\\(p\_{1}\\)に戻って、楕円としても中心は\\(c\_0\\)、\\(c\_1\\)の2つ。



2点\\(p\_0(x\_0, y\_0)\\)、\\(p\_1(x\_1, y\_1)\\)を通る楕円は、x軸が\\(\phi\\)傾いている。計算が簡単な座標に変換するには、\\(-\phi\\)回転させたい。この回転を先行すると、楕円上の2点の座標が複雑になる。
少し考えて、まず先に、楕円上の2点の中点を原点に移動させるのがよさそうだ。
2つ求まる楕円の中心と楕円上の2点の中点は、1直線上にあるからだ。

2点の中点の座標を以下のとおりとする。

<div>
$$
\begin{equation}
  p_{0m1}(x_{0m1}, y_{0m1}) =
    ({{x_0 + x_1}\over 2}, {{y_0 + y_1}\over 2}) \label{p0m1}
\end{equation}
$$

</div>


実際に\\(p\_{0t}\\)、\\(p\_{1t}\\)を計算してみよう。

<div >
$$\begin{align}
  p_{0t} &= \pmatrix{ 1\over{r_x} & 0 \cr 0 & 1\over{r_y} }
    \pmatrix{ \cos(-\phi) & -\sin(-\phi)\cr \sin(-\phi) & \cos(-\phi) } 
    \pmatrix{ {x_0} - x_{0m1} \cr {y_0} - y_{0m1} } \\
  p_{1t} &= \pmatrix{ 1\over{r_x} & 0 \cr 0 & 1\over{r_y} }
    \pmatrix{ \cos(-\phi) & -\sin(-\phi)\cr \sin(-\phi) & \cos(-\phi) } 
    \pmatrix{ {x_1} - x_{0m1} \cr {y_1} - y_{0m1} } \label{p_t}
\end{align}$$
</div>

\\(p\_{0t}\\)、\\(p\_{1t}\\)は\\(p\_{ct}\\)を中心とした半径1の円上にある。

\\(p\_{0t}\\)、\\(p\_{1t}\\)を通る直線に直交するベクトルは次のように\\({\pi\over2}(=90^\circ)\\)の回転を与えればよい。\\(p\_{0t}\\)、\\(p\_{1t}\\)は原点が中点なので、それぞれ\\({\pi\over2}\\)回転するとことで、それぞれが、求める中心の方向に向かうベクトルになる。

<div >
$$
\begin{align}
  p_{0tc} &= \pmatrix{\cos{\pi\over2} & -\sin{\pi\over2} \cr
    \sin{\pi\over2} & \cos{\pi\over2} } p_{0t} \\
  p_{1tc} &= \pmatrix{\cos{\pi\over2} & -\sin{\pi\over2} \cr
    \sin{\pi\over2} & \cos{\pi\over2} } p_{1t} 
\end{align}
$$
</div>

この\\(p\_{0tc}\\)、\\(p\_{1tc}\\)のベクトルの長さを1にする。
\\(p\_{0tc}\\)、\\(p\_{1tc}\\)、\\(p\_{0t}\\)、\\(p\_{1t}\\)は長さが同じなので、\\(p\_{t0}\\)の長さで代表する。


<div >
$$
  \begin{align}
    \lVert{p_{0tc}}\rVert &= \lVert{p_{0t}}\rVert \\
      &=\sqrt{ {x_{0t}}^2 + {y_{0t}}^2 }
  \end{align}
$$
</div>

<div>
$$
  \begin{equation}
    p_{0tc_e} = \pmatrix{ {1\over{\lVert{p_{0t}}\rVert}} & 0 \cr
      0 & {1\over{\lVert{p_{0t}}\rVert}}} p_{tc0} \label{p_0tce} 
  \end{equation}
$$
</div>

倍率\\(\alpha\\)を\\(p\_{0tc\_e}\\)、\\(p\_{1tc\_e}\\)にかけた点と\\(p\_{0t}\\)、\\(p\_{1t}\\)の距離が1になるように\\(\alpha\\)を求める。\\(\alpha\\)を\\(p\_{0tc\_e}\\)、\\(p\_{1tc\_e}\\)にかけた点は円の中心だ。

\\(\alpha\\)は、半径が1の円であることから求めることができる。

<div >
$$
\begin{align}
  \sqrt{ \alpha^2 + ({x_{0t}}^2 + {y_{0t}}^2) } &= 1 \\
  \alpha &= \pm \sqrt{ 1 - ({x_{0t}}^2 + {y_{0t}}^2)  }
\end{align}
$$
</div>

2つの\\(\alpha\\)のうち正を使うことにする。

<div >
$$
\begin{equation}
  \alpha = \sqrt{ 1 - ({x_{0t}}^2 + {y_{0t}}^2) } \label{alpha_2}
\end{equation}
$$
</div>

\\(c\_{t0}\\)、\\(c\_{t1}\\)求める。
\\(c\_{t0_e}\\)、\\(c\_{t1_e}\\)を\\(\alpha\\)倍することで円の中心を求める。

<div>
$$
\begin{align}
  c_{t0} &= \pmatrix{\alpha&0\cr 0&\alpha} p_{0tc_e} \\
  c_{t1} &= \pmatrix{\alpha&0\cr 0&\alpha} p_{1tc_e} 
\end{align}
$$
</div>

楕円の中心は、今までのマトリックスの逆マトリックスをかけて\\(p\_{0m1}\\)だけ座標を移動することで求めることができる。

計算したのは、半径を1とした円の中心。楕円とした場合の中心\\({c\_0}'\\)、\\({c\_1}'\\)は、

<div>
$$
  \begin{align}
    {c_0}' &= \pmatrix{r_x&0 \cr 0 & r_y}c_{t0} \label{c0_d_0} \\
    {c_1}' &= \pmatrix{r_x&0 \cr 0 & r_y}c_{t1} \label{c1_d_0}
  \end{align}
$$
</div>

\\(\phi\\)回転と\\(p\_{0m1}\\)への移動をおこなう。

<div>
$$
\begin{align}
  c_0 &= \pmatrix{\cos(\phi) & -\sin(\phi) \cr
    \sin(\phi) & \cos(\phi)} {c_{t0}}' + p_{0m1} \\
  c_1 &= \pmatrix{\cos(\phi) & -\sin(\phi) \cr
    \sin(\phi) & \cos(\phi)} {c_{t1}}' + p_{0m1}
\end{align}
$$
</div>

これで、楕円の中心\\(c\_0\\)、\\(c\_1\\)計算できた。

### implementation notesにあわせた式の調整
自身での中心の計算式は得られた。implementation notesのそれと等しいものか確認したい。implementation notesの文字と上の式の文字を調整して、一致していることを調べよう。

#### \\((x_1'、y_1')\\)と\\(p\_0t\\)の関係

[implementation notes](https://www.w3.org/TR/SVG11/paths.html#ArcConversionCenterToEndpoint)は、\\((x_1'、y_1')\\)を用いている。


<div>
$$
\begin{align}
  \pmatrix{{x_1}' \cr {y_1}'} &=
    \pmatrix{\cos\phi & \sin\phi \cr -\sin\phi & \cos\phi}
    \pmatrix{ { {x\_1 - x\_2} \over 2 } \cr
      { {y\_1 - y\_2} \over 2 } }  \tag{F.5.1}\label{f_5_1} \\
  &= \pmatrix{\cos(-\phi) & -\sin(-\phi) \cr \sin(-\phi) & \cos(-\phi)}
    \pmatrix{ x_1 - { {x_1 + x_2} \over 2 } \cr
      y_1 - { {y_1 + y_2} \over 2 } } \notag
\end{align}
$$
</div>

添え字を\\(1\to0\\)と合わせれば、\\(\eqref{p_t}\\)の式は、\\(\eqref{f_5_1}\\)に\\(\pmatrix{{1\over r\_x} & 0 \cr 0 & {1 \over r\_y}}\\)をかけた式になっている。

<div>
$$
  \begin{align}
    p_{0t} &= \pmatrix{ 1\over{r_x}&0 \cr 0& 1\over{r_y}}
      \pmatrix{{x_1}' \cr {y_1}'} \\
    &= \pmatrix{ {x_1}'\over{ r_x } \cr {y_1}'\over{ r_y } }
  \end{align}
$$
</div>

<div>
$$
  \begin{align}
    \alpha &= \sqrt{ 1 - (({{x_1}'\over{ r_x }})^2
        + ({{y_1}'\over{ r_y }})^2) } \\
      &=\sqrt{ { {r_x}^2{r_y}^2 - {{r_y}^2}{{x_1}'^2} - {{r_x}^2}{{y_1}'^2} }
          \over { {r_x}^2{r_y}^2 }  } \\
  \end{align}
$$
</div>

\\(\eqref{p_0tce}\\)を\\(\pmatrix{{x\_1}' \cr {y\_1}'}\\)を用いて表してみよう。

<div>
$$
  \begin{align}
    \lVert{p_{0t_e}}\rVert &= \sqrt{{{({{x_1}'})^2}\over{{r_x}^2}}
        + {{({{y_1}'})^2}\over{{r_y}^2}} } \\
      &=\sqrt{{{{{r_y}^2({{x_1}'})^2}}
        + {{r_x}^2({{y_1}'})^2}\over{{{r_x}^2}{r_y}^2}} }
  \end{align}
$$
</div>

<div>
$$
  \begin{align} p_{0tc_e} &= \pmatrix{
    {1 \over \sqrt{{{{{r_y}^2({{x_1}'})^2}} 
        + {{r_x}^2({{y_1}'})^2}\over{{{r_x}^2}{r_y}^2}} } } &0 \cr
    0 & {1 \over \sqrt{{{{{r_y}^2({{x_1}'})^2}}
        + {{r_x}^2({{y_1}'})^2}\over{{{r_x}^2}{r_y}^2}} } } }
      \pmatrix{\cos{\pi \over 2} & -\sin{\pi \over 2} \cr
        \sin{\pi \over 2} & \cos{\pi \over 2 }}
      \pmatrix { x_{0t} \cr y_{0t} } \label{calc_cd0_from_p0te} \\
    &= {1 \over \sqrt{{{{{r_y}^2({{x_1}'})^2}}
      + {{r_x}^2({{y_1}'})^2}\over{{{r_x}^2}{r_y}^2}} } }
      \pmatrix { {{y_0}' \over r_y} \cr -{{x_0}' \over r_x} }
  \end{align}
$$
</div>

<div>
$$
  \begin {align}
    c_{0t} &=  {\alpha \over \sqrt{{{{{r_y}^2({{x_1}'})^2}}
      + {{r_x}^2({{y_1}'})^2}\over{{{r_x}^2}{r_y}^2}} } }
      \pmatrix { {{y_0}' \over r_y} \cr -{{x_0}' \over r_x} } 
        \label{calc_cd0_from_c0t} \\
    &= {\sqrt{ { {r_x}^2{r_y}^2 - {{r_y}^2}{{x_1}'^2} - {{r_x}^2}{{y_1}'^2} }
        \over { {r_x}^2{r_y}^2 }  } \over
      \sqrt{{{{r_y}^2({{x_1}'})^2}}
        + {{r_x}^2({{y_1}'})^2}\over{{{r_x}^2}{r_y}^2}}} 
      \pmatrix { {{y_0}' \over r_y} \cr -{{x_0}' \over r_x} } \\
    &= \sqrt{ { {r_x}^2{r_y}^2 - {{r_y}^2}{{x_1}'^2} - {{r_x}^2}{{y_1}'^2} }
        \over {{{r_y}^2({{x_1}'})^2} + {{r_x}^2({{y_1}'})^2}} }
      \pmatrix{{{y_0}' \over {r_y} } \cr - {{x_0}' \over {r_x}}}
  \end{align}
$$
</div>

\\(\eqref{c0_d_0}\\)について\\(\pmatrix{{x\_1}' \cr {y\_1}'}\\)を用いて表してみよう。

<div>
$$
  \begin{align}
    {c_0}' &= \pmatrix{r_x&0 \cr 0&r_y} 
      \pmatrix{
        \sqrt{ { {r_x}^2{r_y}^2 - {{r_y}^2}{{x_1}'^2} - {{r_x}^2}{{y_1}'^2} }
          \over {{{r_y}^2({{x_1}'})^2} + {{r_x}^2({{y_1}'})^2}} }
            {{y_0}' \over {r_y} } \cr
        \sqrt{ { {r_x}^2{r_y}^2 - {{r_y}^2}{{x_1}'^2} - {{r_x}^2}{{y_1}'^2} }
          \over {{{r_y}^2({{x_1}'})^2} + {{r_x}^2({{y_1}'})^2}} }
        {- {x_0}' \over {r_x}}  } \\
    &= \sqrt{ { {r_x}^2{r_y}^2 - {{r_y}^2}{{x_1}'^2} - {{r_x}^2}{{y_1}'^2} }
        \over {{{r_y}^2({{x_1}'})^2} + {{r_x}^2({{y_1}'})^2}} }
      \pmatrix{{r_x{y_0}' \over {r_y} } \cr  {- r_y{x_0}' \over {r_x}}  } \label{calc_c0d}
  \end{align}
$$
</div>

\\(\eqref{calc_c0d}\\)は<a href="https://www.w3.org/TR/SVG11/implnote.html#ArcConversionEndpointToCenter">(F.6.5.1)</a>の+側を表す。\\(\eqref{calc_cd0_from_p0te}\\)のところから、\\(c\_{0t}\\)を\\(c\_{1t}\\)と置き換えて計算すると-側になる。

